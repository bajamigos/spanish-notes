<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Tarea 3 SIELE S4: Di√°logo de Rol | Grok Mode üöÄ</title>
  <style>
    body {
      font-family: 'Inter', sans-serif;
      background: linear-gradient(to bottom, #000000, #0a0a0a);
      color: white;
      text-align: center;
      padding: 20px;
    }
    .recorder-card {
      margin-top: 20px;
      padding: 20px;
      border: 1px solid #1DA1F2;
      border-radius: 15px;
      background: rgba(255, 255, 255, 0.05);
      max-width: 400px;
      margin-left: auto;
      margin-right: auto;
    }
    .recorder-buttons {
      margin-top: 10px;
      display: flex;
      justify-content: center;
      gap: 10px;
    }
    .recorder-button {
      background-color: #1DA1F2;
      border: none;
      border-radius: 5px;
      padding: 10px 15px;
      color: white;
      font-weight: bold;
      cursor: pointer;
    }
    .recorder-button:hover {
      background-color: #0d8ddb;
    }
    .recorder-button:disabled {
      background-color: #666;
      cursor: not-allowed;
    }
    .status-message {
      margin-top: 10px;
      color: #1DA1F2;
      font-size: 14px;
    }
  </style>
</head>
<body>
  <h1>Tarea 3 SIELE S4: Di√°logo de Rol</h1>
  <div class="recorder-card">
    <div id="recorder-display">00:00</div>
    <div class="recorder-buttons">
      <button id="startBtn" onclick="startRecording()" class="recorder-button">üéôÔ∏è Start Record</button>
      <button id="stopBtn" onclick="stopRecording()" class="recorder-button" disabled>üõë Stop & Send</button>
    </div>
    <div id="status" class="status-message"></div>
  </div>

  <script>
    let recorder, audioStream, audioChunks = [];
    let recordingSeconds = 0, recordingTimer;
    const statusDiv = document.getElementById("status");
    const display = document.getElementById("recorder-display");
    const startBtn = document.getElementById("startBtn");
    const stopBtn = document.getElementById("stopBtn");

    function updateRecorderDisplay() {
      const minutes = Math.floor(recordingSeconds / 60);
      const secs = recordingSeconds % 60;
      display.textContent = `${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    }

    async function startRecording() {
      if (!navigator.mediaDevices || !window.MediaRecorder) {
        statusDiv.textContent = "üé§ Recording not supported in this browser.";
        return;
      }

      try {
        statusDiv.textContent = "üéôÔ∏è Recording...";
        audioChunks = [];
        recordingSeconds = 0;
        updateRecorderDisplay();
        
        // Enable/disable buttons
        startBtn.disabled = true;
        stopBtn.disabled = false;

        audioStream = await navigator.mediaDevices.getUserMedia({ 
          audio: {
            echoCancellation: true,
            noiseSuppression: true,
            sampleRate: 44100
          } 
        });
        
        recorder = new MediaRecorder(audioStream, {
          mimeType: 'audio/webm;codecs=opus' // Better browser support
        });
        
        recorder.ondataavailable = e => {
          if (e.data.size > 0) {
            audioChunks.push(e.data);
          }
        };
        
        recorder.start();
        
        recordingTimer = setInterval(() => {
          recordingSeconds++;
          updateRecorderDisplay();
          if (recordingSeconds >= 180) stopRecording(); // Auto-stop at 3 min
        }, 1000);
        
      } catch (err) {
        statusDiv.textContent = "‚ùå Error accessing microphone: " + err.message;
        startBtn.disabled = false;
        stopBtn.disabled = true;
        console.error("Recording error:", err);
      }
    }

    function stopRecording() {
      if (!recorder || recorder.state !== "recording") {
        statusDiv.textContent = "‚ö†Ô∏è Not recording right now.";
        return;
      }

      recorder.stop();
      clearInterval(recordingTimer);
      statusDiv.textContent = "‚è≥ Processing recording...";
      
      // Stop all tracks
      if (audioStream) {
        audioStream.getTracks().forEach(track => track.stop());
      }

      recorder.onstop = () => {
        const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
        uploadAudio(audioBlob);
        
        // Reset buttons
        startBtn.disabled = false;
        stopBtn.disabled = true;
      };
    }

    async function uploadAudio(blob) {
      const formData = new FormData();
      formData.append('file', blob, `recording_${Date.now()}.webm`);
      formData.append('timestamp', new Date().toISOString());

      try {
        statusDiv.textContent = "‚è≥ Uploading audio...";
        
        const response = await fetch('https://script.google.com/macros/s/AKfycbwbPkiabXBE1hRXVomxpOxubpoiZ6xZtoi1YAT76ApicpHU482T_uHNWWbiGr8igd-Blg/exec', {
          method: 'POST',
          body: formData,
          mode: 'no-cors' // This might help with CORS issues
        });

        // With no-cors mode, we can't read the response
        statusDiv.textContent = "‚úÖ Audio sent successfully!";
        
        // Create download link
        const audioUrl = URL.createObjectURL(blob);
        const downloadLink = document.createElement("a");
        downloadLink.href = audioUrl;
        downloadLink.download = `recording_${Date.now()}.webm`;
        downloadLink.textContent = "‚¨áÔ∏è Download your recording";
        downloadLink.style.display = "block";
        downloadLink.style.marginTop = "10px";
        downloadLink.style.color = "#1DA1F2";
        downloadLink.style.textDecoration = "none";
        
        // Clear previous download links
        const existingLinks = statusDiv.querySelectorAll('a');
        existingLinks.forEach(link => link.remove());
        
        statusDiv.appendChild(downloadLink);
        
      } catch (error) {
        console.error("Upload error:", error);
        statusDiv.textContent = "‚ùå Upload failed: " + error.message;
        
        // Still provide download option
        const audioUrl = URL.createObjectURL(blob);
        const downloadLink = document.createElement("a");
        downloadLink.href = audioUrl;
        downloadLink.download = `recording_${Date.now()}.webm`;
        downloadLink.textContent = "‚¨áÔ∏è Download recording (upload failed)";
        downloadLink.style.display = "block";
        downloadLink.style.marginTop = "10px";
        downloadLink.style.color = "#ff6b6b";
        downloadLink.style.textDecoration = "none";
        statusDiv.appendChild(downloadLink);
      }
    }
  </script>
</body>
</html>
